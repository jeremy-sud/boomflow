// BOOMFLOW - Database Schema
// Corporate gamification system with kudos and badges

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ==================== USERS AND ORGANIZATIONS ====================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  username      String    @unique
  image         String?
  githubId      String?   @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])
  teamId         String?
  team           Team?         @relation(fields: [teamId], references: [id])

  // Kudos and Badges
  kudosSent     Kudo[]      @relation("KudosSent")
  kudosReceived Kudo[]      @relation("KudosReceived")
  badges        UserBadge[]

  // Notifications and GitHub
  notifications Notification[]
  githubStats   GitHubStats?

  // NextAuth
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model Organization {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  logo        String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]
  teams       Team[]
  badges      Badge[]

  @@map("organizations")
}

model Team {
  id             String       @id @default(cuid())
  name           String
  slug           String
  description    String?
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  members        User[]

  @@unique([organizationId, slug])
  @@map("teams")
}

// ==================== KUDOS SYSTEM ====================

model Kudo {
  id         String   @id @default(cuid())
  message    String
  isPublic   Boolean  @default(true)
  createdAt  DateTime @default(now())

  // Relations
  fromId     String
  from       User     @relation("KudosSent", fields: [fromId], references: [id], onDelete: Cascade)
  toId       String
  to         User     @relation("KudosReceived", fields: [toId], references: [id], onDelete: Cascade)
  categoryId String?
  category   KudoCategory? @relation(fields: [categoryId], references: [id])

  @@map("kudos")
}

model KudoCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  emoji       String
  description String?
  kudos       Kudo[]

  @@map("kudo_categories")
}

// ==================== BADGE SYSTEM ====================

model Badge {
  id             String        @id @default(cuid())
  name           String
  slug           String        @unique
  description    String
  svgIcon        String        // Default SVG icon
  category       BadgeCategory
  tier           BadgeTier     @default(BRONZE)
  isAutomatic    Boolean       @default(false)
  triggerType    TriggerType?
  triggerValue   Int?          // Value for automatic trigger
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])
  userBadges     UserBadge[]
  skins          BadgeSkin[]   // Available skins for this badge

  @@map("badges")
}

model BadgeSkin {
  id          String   @id @default(cuid())
  name        String   // e.g., "Crystal", "Gem", "Academic", "Minimalist"
  slug        String   @unique
  description String?
  svgIcon     String   // SVG content for this skin variant
  style       SkinStyle @default(DEFAULT)
  isDefault   Boolean  @default(false)
  isPremium   Boolean  @default(false) // Requires patron status
  createdAt   DateTime @default(now())

  // Relations
  badgeId     String?
  badge       Badge?    @relation(fields: [badgeId], references: [id], onDelete: SetNull)
  userBadges  UserBadge[]

  @@map("badge_skins")
}

model UserBadge {
  id        String   @id @default(cuid())
  awardedAt DateTime @default(now())
  awardedBy String?  // Username who awarded (null if automatic)
  reason    String?
  isVisible Boolean  @default(true)

  // Relations
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  skinId    String?  // Optional custom skin
  skin      BadgeSkin? @relation(fields: [skinId], references: [id], onDelete: SetNull)

  @@unique([userId, badgeId])
  @@map("user_badges")
}

// ==================== ENUMS ====================

enum BadgeCategory {
  COLLABORATION   // Team collaboration and mentoring
  CODING          // Code quality and development skills
  LEADERSHIP      // Technical and team leadership
  INNOVATION      // Creative solutions and new ideas
  CULTURE         // Company culture and values
  ONBOARDING      // Onboarding milestones
  DOCUMENTATION   // Docs, wikis, and knowledge sharing
  QUALITY         // Testing, QA, and reliability
  DEVOPS          // Infrastructure, CI/CD, deployment
  SPECIAL         // Unique achievements
  COMMUNITY       // Peer-to-peer social badges
  PREMIUM         // Patron/investment badges
  MILESTONE       // Cumulative achievements
  GROWTH          // Learning and professional development
}

enum SkinStyle {
  DEFAULT         // Original badge design
  CRYSTAL         // Gem/crystal faceted design
  ACADEMIC        // Formal, scholarly design
  MINIMALIST      // Clean, simple design
  VINTAGE         // Retro, classic design
  NEON            // Modern, glowing design
}

enum BadgeTier {
  BRONZE
  SILVER
  GOLD
}

enum TriggerType {
  KUDOS_RECEIVED    // Receive X kudos
  KUDOS_SENT        // Send X kudos
  CODE_REVIEWS      // Complete X code reviews
  PULL_REQUESTS     // Create X PRs
  ISSUES_CLOSED     // Close X issues
  STREAK_DAYS       // X consecutive active days
  FIRST_ACTION      // First action of type
  MANUAL            // Manually awarded
  // GitHub triggers
  GITHUB_COMMIT     // Synced GitHub commits
  GITHUB_PR         // Synced GitHub PRs
  GITHUB_REVIEW     // Synced GitHub reviews
  // Social economy triggers
  MANUAL_PEER_AWARD // Awarded by a colleague (peer-to-peer)
  INVESTMENT        // Awarded by investment/donation (Patron)
  PEER_AWARDS_COUNT // Count of peer-to-peer badges received
  BADGES_COUNT      // Total badges earned
  TENURE_DAYS       // Days since joining
}

enum NotificationType {
  KUDO_RECEIVED     // Received a kudo
  BADGE_EARNED      // Earned a badge
  BADGE_PROGRESS    // Close to earning a badge
  MENTION           // Got mentioned
  SYSTEM            // System notification
  PEER_AWARD        // Received peer recognition
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  data      Json?            // Additional data (badgeId, kudoId, etc)
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Relations
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@map("notifications")
}

// ==================== GITHUB STATS ====================

model GitHubStats {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // GitHub Stats
  commits       Int      @default(0)
  pullRequests  Int      @default(0)
  reviews       Int      @default(0)
  issuesClosed  Int      @default(0)
  contributions Int      @default(0)
  
  // Metadata
  lastSyncAt    DateTime @default(now())
  syncError     String?
  
  @@map("github_stats")
}

// ==================== NEXTAUTH ====================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
